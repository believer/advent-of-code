// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Utils$AdventOfCode2018 = require("../utils/Utils.bs.js");

var ios = Caml_format.caml_int_of_string;

function parseLine(row) {
  var match = row.match((/\#(\d+) @ (\d+),(\d+)\: (\d+)x(\d+)/));
  if (match !== null) {
    return /* tuple */[
            Caml_array.caml_array_get(match, 1),
            Caml_format.caml_int_of_string(Caml_array.caml_array_get(match, 2)),
            Caml_format.caml_int_of_string(Caml_array.caml_array_get(match, 3)),
            Caml_format.caml_int_of_string(Caml_array.caml_array_get(match, 4)),
            Caml_format.caml_int_of_string(Caml_array.caml_array_get(match, 5))
          ];
  } else {
    return /* tuple */[
            "0",
            0,
            0,
            0,
            0
          ];
  }
}

function updateValue(current, newValue) {
  if (current === "0" || current === newValue) {
    return newValue;
  } else {
    return "x";
  }
}

function createMatrix(input) {
  var matrix = $$Array.make_matrix(1000, 1000, "0");
  Belt_Array.map(input, (function (row) {
          var match = parseLine(row);
          var sy = match[4];
          var y = match[2];
          var x = match[1];
          var id = match[0];
          for(var i = 0 ,i_finish = match[3] - 1 | 0; i <= i_finish; ++i){
            var currentX = Caml_array.caml_array_get(Caml_array.caml_array_get(matrix, y), x + i | 0);
            Caml_array.caml_array_set(Caml_array.caml_array_get(matrix, y), x + i | 0, updateValue(currentX, id));
            for(var j = 0 ,j_finish = sy - 1 | 0; j <= j_finish; ++j){
              var currentY = Caml_array.caml_array_get(Caml_array.caml_array_get(matrix, y + j | 0), x + i | 0);
              Caml_array.caml_array_set(Caml_array.caml_array_get(matrix, y + j | 0), x + i | 0, updateValue(currentY, id));
            }
          }
          return /* () */0;
        }));
  return matrix;
}

function findOverlap(input) {
  return Belt_Array.keep(Utils$AdventOfCode2018.flatten(createMatrix(input)), (function (v) {
                return v === "x";
              })).length;
}

function findFabric(input) {
  var matrix = createMatrix(input);
  var output = Belt_Array.get(Belt_Array.keep(Belt_Array.map(Belt_Array.map(input, (function (row) {
                      var match = parseLine(row);
                      var sy = match[4];
                      var sx = match[3];
                      var y = match[2];
                      var x = match[1];
                      var currentMatrix = $$Array.make_matrix(sy, sx, "0");
                      for(var i = 0 ,i_finish = sx - 1 | 0; i <= i_finish; ++i){
                        Caml_array.caml_array_set(Caml_array.caml_array_get(currentMatrix, 0), i, Caml_array.caml_array_get(Caml_array.caml_array_get(matrix, y), x + i | 0));
                        for(var j = 0 ,j_finish = sy - 1 | 0; j <= j_finish; ++j){
                          Caml_array.caml_array_set(Caml_array.caml_array_get(currentMatrix, j), i, Caml_array.caml_array_get(Caml_array.caml_array_get(matrix, y + j | 0), x + i | 0));
                        }
                      }
                      return /* tuple */[
                              currentMatrix,
                              match[0]
                            ];
                    })), (function (param) {
                  return /* tuple */[
                          Belt_Array.keep(param[0], (function (row) {
                                  return row.includes("x");
                                })),
                          param[1]
                        ];
                })), (function (param) {
              return param[0].length === 0;
            })), 0);
  if (output !== undefined) {
    return output[1];
  } else {
    return "Couldn't find a fabric without overlap";
  }
}

exports.ios = ios;
exports.parseLine = parseLine;
exports.updateValue = updateValue;
exports.createMatrix = createMatrix;
exports.findOverlap = findOverlap;
exports.findFabric = findFabric;
/* No side effect */
