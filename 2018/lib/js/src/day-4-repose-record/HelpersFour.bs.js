// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Utils$AdventOfCode2018 = require("../utils/Utils.bs.js");

var dateRe = (/\d{4}-\d{2}-\d{2} \d{2}:(\d{2})/);

var guardIdRe = (/\d+/);

var firstWordRe = (/^\w+/);

function parseDate(row) {
  var match = row.match(dateRe);
  if (match !== null) {
    return /* tuple */[
            Caml_array.caml_array_get(match, 0),
            Caml_array.caml_array_get(match, 1)
          ];
  } else {
    return /* tuple */[
            "",
            ""
          ];
  }
}

function guardState(guard) {
  var match = guard.match(firstWordRe);
  if (match !== null) {
    var match$1 = Caml_array.caml_array_get(match, 0);
    switch (match$1) {
      case "falls" : 
          return /* FallsAsleep */0;
      case "wakes" : 
          return /* WakeUp */1;
      default:
        return /* UnknownState */2;
    }
  } else {
    return /* UnknownState */2;
  }
}

var latestGuard = /* record */[/* contents */""];

function guardId(row) {
  var match = row.match(guardIdRe);
  if (match !== null) {
    latestGuard[0] = Caml_array.caml_array_get(match, 0);
    return Caml_array.caml_array_get(match, 0).replace("#", "");
  } else {
    return latestGuard[0];
  }
}

function sortByDate(param, param$1) {
  return Utils$AdventOfCode2018.dateAsInt(param[0][0]) - Utils$AdventOfCode2018.dateAsInt(param$1[0][0]) | 0;
}

function createList(input) {
  var list = { };
  var fellAsleep = /* record */[/* contents */0];
  Belt_Array.forEach(Belt_Array.map(Utils$AdventOfCode2018.sortInPlaceWith(Belt_Array.map(input, (function (row) {
                      var split = row.split("] ");
                      return /* tuple */[
                              parseDate(Caml_array.caml_array_get(split, 0)),
                              Caml_array.caml_array_get(split, 1)
                            ];
                    })), sortByDate), (function (param) {
              var row = param[1];
              return /* tuple */[
                      param[0][1],
                      guardState(row),
                      guardId(row)
                    ];
            })), (function (param) {
          var id = param[2];
          var minute = param[0];
          switch (param[1]) {
            case 0 : 
                var match = list[id];
                if (match === undefined) {
                  list[id] = /* tuple */[
                    0,
                    /* array */[]
                  ];
                }
                fellAsleep[0] = Caml_format.caml_int_of_string(minute);
                return /* () */0;
            case 1 : 
                var match$1 = list[id];
                if (match$1 !== undefined) {
                  var now = Caml_format.caml_int_of_string(minute);
                  var diff = now - fellAsleep[0] | 0;
                  var newInterval = Utils$AdventOfCode2018.range(fellAsleep[0], now);
                  list[id] = /* tuple */[
                    diff + match$1[0] | 0,
                    Belt_Array.concat(/* array */[newInterval], match$1[1])
                  ];
                  return /* () */0;
                } else {
                  return /* () */0;
                }
            case 2 : 
                return /* () */0;
            
          }
        }));
  return Js_dict.entries(list);
}

function createInterval(arr) {
  return Utils$AdventOfCode2018.flatten(Belt_Array.map(arr, Belt_List.toArray));
}

function getMostSleepy(guard) {
  return Belt_Array.get(Belt_Array.keep(Utils$AdventOfCode2018.sortInPlaceWith(Js_dict.entries(guard), (function (param, param$1) {
                        return param$1[1] - param[1] | 0;
                      })), (function (param) {
                    return param[1] > 0;
                  })), 0);
}

function updateDictByOne(dict, id) {
  var match = dict[id];
  dict[id] = match !== undefined ? match + 1 | 0 : 1;
  return /* () */0;
}

exports.dateRe = dateRe;
exports.guardIdRe = guardIdRe;
exports.firstWordRe = firstWordRe;
exports.parseDate = parseDate;
exports.guardState = guardState;
exports.latestGuard = latestGuard;
exports.guardId = guardId;
exports.sortByDate = sortByDate;
exports.createList = createList;
exports.createInterval = createInterval;
exports.getMostSleepy = getMostSleepy;
exports.updateDictByOne = updateDictByOne;
/* dateRe Not a pure module */
